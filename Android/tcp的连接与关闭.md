# TCP的连接与关闭

## 1.1 TCP的连接

TCP是通过三次握手进行连接的

TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。

在TCP中有一个消息是大家都必须知道的，那就是ACK（确认应答），他的作用是*当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。* 这里的ACK，相当于在两个人聊天停顿时能回应你的那个人的角色。

如果在发送端将数据发出之后得到了确认应答，说明数据已经成功到达对端，否则，你的数据可能就是半路丢失了。

下面我们来看看**三次握手**的示意图：

![](http://img.blog.csdn.net/20150803153852016)

这里我们看出主机A是客户端，主机B是服务器，客户端先向服务器发送请求：

- 第一次握手：其实是客户端发送一个带有SYN的数据报文段发送给服务器，对应在图片中就是从主机A到主机B（SYN＝1，seq＝i），seq为对应序列号为i。之后主机A进入SYN_SENT状态。同时等待服务器的确认
- 第二次握手：服务器收到同步报文段后（也就是带有SYN的同步报文段），必须确定客户的同步报文段。然后自己也发送一个带有SYN的报文段，对应到图片中的第二个报文段，其中SYN＝1，表示这是一个同步报文段，ACK＝1，表示这是一个确认报文段，确认序号值为i+1，序号值为j。
- 第三次握手：这次就是客户端收到确认同步报文段后，它向服务器发送确认包，对应到图片中也就是第三个报文段，ack＝1也就是表示这是一个确认报文段，确认序号为j+1

这里我们**需要注意**，第一次握手是发送一个序列号，而第二次的序列号是单独发送的，第二次的确认号是第一次握手序列号＋1，第三次握手的序列号是第二次握手的确认号，第三次握手的确认号是第二次握手的序列号＋1。（ `这里在刷面试题时曾经出现过`）

### 没有收到确认应答的情况

当客户端没有收到确认应答时，不要果断的认定数据丢失了，一般会有两种情况：

- 可能是数据对方已经收到，只是返回的确认应答在途中丢失
- 还有可能因为一些其它原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也很多


## 1.2 TCP的关闭
TCP的关闭时通过四次握手来实现的，首先我们来看一下四次握手的示意图：

![](http://img.blog.csdn.net/20150803153635912)

我们看到关闭TCP的时候多了一步，因为当服务器收到FIN报文时要先保证数据已经全部发送完毕后才能关闭，所以只能先回复一个ACK报文，告诉客户端已经收到关闭TCP连接的请求，当所有的报文发送完毕后发送FIN报文。

当然，在发送ACK后客户端进入TIME_WAIT状态，如果服务器没有收到ACK则可以重传，在客户端等待了2MSL后依然没有收到回复，则证明服务器已正常关闭，客户端关闭，TCP连接关闭。

## 总结
那么为什么连接的时候是三次握手，关闭的时候却是四次握手？

```
	因为当服务器收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。
	其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，服务器
	收到FIN报文时要先保证数据已经全部发送完毕后才能关闭，所以只能先回复一个ACK
	报文，告诉客户端已经收到关闭TCP连接的请求，当所有的报文发送完毕后发送FIN报
	文，因此不能一起发送。故需要四步握手。
```

为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

```
	虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假
	想网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能
	丢失的ACK报文。
```


